<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/02/07/latex-shu-xue-fu-hao/"/>
      <url>/2023/02/07/latex-shu-xue-fu-hao/</url>
      
        <content type="html"><![CDATA[<h1 id="点"><a href="#点" class="headerlink" title="点"></a>点</h1><ol><li>单个点 ($\cdot$) ： <code>$\cdot$</code></li><li>横向多个点 ($\cdots$) : <code>$\cdots$</code></li><li>竖向多个点 ($\vdots$) : <code>$\vdots$</code></li><li>斜向多个点 ($\ddots$) : <code>$\ddots$</code></li></ol><h1 id="数学字体"><a href="#数学字体" class="headerlink" title="数学字体"></a>数学字体</h1><blockquote><p>math<strong>bb</strong>：blackboard bold（黑板粗体），用于期望<br>math<strong>bf</strong>：math boldface，用于矩阵、向量<br>math<strong>rm</strong>：math roman，罗马体（整体），用于微分符号d、二项式系数C、等号上的def、自然常数e、虚数单位i<br>math<strong>cal</strong>：math calligraphy（美术字），用于集合，分布</p></blockquote><table><thead><tr><th><code>A</code></th><th><code>$A$</code></th><th><code>$\mathbb&#123;A&#125;$</code></th><th><code>$\mathbf&#123;A&#125;$</code></th><th><code>$\mathrm&#123;A&#125;$</code></th><th><code>$\mathcal&#123;A&#125;$</code></th></tr></thead><tbody><tr><td>A</td><td>$A$</td><td>$\mathbb{A}$</td><td>$\mathbf{A}$</td><td>$\mathrm{A}$</td><td>$\mathcal{A}$</td></tr></tbody></table><blockquote><p>参考</p><ul><li><a href="https://www.jianshu.com/p/6de552393933">Latex数学字体</a></li><li><a href="https://blog.csdn.net/dujuancao11/article/details/126089781">【latex】\mathbf{} \matrm{}</a></li></ul></blockquote><h1 id="公式标号"><a href="#公式标号" class="headerlink" title="公式标号"></a>公式标号</h1><p>在<strong>块级公式(<code>$$$$</code>)中</strong>使用<code>\tag&#123;自定义编号&#125;</code><br>引用使用<code>$(自定义编号)$</code></p><h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><blockquote><p>将下标放置于文本正上&#x2F;下方</p></blockquote><p><code>$\sum_&#123;i=1&#125;^n$</code><br>$\sum_{i&#x3D;1}^n$</p><p><code>$\sum \limits_&#123;i=1&#125; \limits^n$</code><br>$\sum \limits_{i&#x3D;1} \limits^n$</p><p>需要注意的是其仅仅支持应用于数学的操作符,若需要在非数学操作符上下方添加文字,需要通过<code>\mathop</code>将表达式转化为数学操作符,示例如下</p><p><code>$\mathop&#123;minimize&#125; \limits_&#123;w,b&#125; J(w, b)$</code><br>$\mathop{minimize} \limits_{w,b} J(w, b)$</p><blockquote><p>参考</p><ul><li>[1] <a href="https://blog.csdn.net/da_kao_la/article/details/84836098">LaTex中把下标置于文本正下方的方法</a></li></ul></blockquote><h1 id="数学模式重音符号1"><a href="#数学模式重音符号1" class="headerlink" title="数学模式重音符号1"></a>数学模式重音符号1</h1><p><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20210923204247.png"></p><h1 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h1><p><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20210923204409.png"></p><h1 id="二元关系"><a href="#二元关系" class="headerlink" title="二元关系"></a>二元关系</h1><p><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20210923204442.png"></p><h1 id="二元运算"><a href="#二元运算" class="headerlink" title="二元运算"></a>二元运算</h1><p><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20210923204458.png"></p><h1 id="“大”运算符"><a href="#“大”运算符" class="headerlink" title="“大”运算符"></a>“大”运算符</h1><p><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20210923204514.png"></p><h1 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h1><p><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20210923204532.png"></p><h1 id="定界符"><a href="#定界符" class="headerlink" title="定界符"></a>定界符</h1><p><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20210923204544.png"></p><h1 id="大定界符"><a href="#大定界符" class="headerlink" title="大定界符"></a>大定界符</h1><p><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20210923204559.png"></p><h1 id="其它符号"><a href="#其它符号" class="headerlink" title="其它符号"></a>其它符号</h1><p><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20210923204614.png"></p><h1 id="非数学符号"><a href="#非数学符号" class="headerlink" title="非数学符号"></a>非数学符号</h1><p><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20210923204637.png"></p><h1 id="AMS定界符"><a href="#AMS定界符" class="headerlink" title="AMS定界符"></a>AMS定界符</h1><p><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20210923204655.png"></p><h1 id="AMS希腊和希伯来字母"><a href="#AMS希腊和希伯来字母" class="headerlink" title="AMS希腊和希伯来字母"></a>AMS希腊和希伯来字母</h1><p><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20210923204712.png"></p><h1 id="AMS二元关系"><a href="#AMS二元关系" class="headerlink" title="AMS二元关系"></a>AMS二元关系</h1><p><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20210923204759.png"></p><h1 id="AMS箭头"><a href="#AMS箭头" class="headerlink" title="AMS箭头"></a>AMS箭头</h1><p><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20210923204821.png"></p><h1 id="AMS二元否定关系符和箭头"><a href="#AMS二元否定关系符和箭头" class="headerlink" title="AMS二元否定关系符和箭头"></a>AMS二元否定关系符和箭头</h1><p><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20210923204837.png"></p><h1 id="AMS二元运算符"><a href="#AMS二元运算符" class="headerlink" title="AMS二元运算符"></a>AMS二元运算符</h1><p><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20210923204859.png"></p><h1 id="AMS其它符号"><a href="#AMS其它符号" class="headerlink" title="AMS其它符号"></a>AMS其它符号</h1><p><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20210923204916.png"></p><h1 id="数字字母"><a href="#数字字母" class="headerlink" title="数字字母"></a>数字字母</h1><p><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20210923204932.png"></p><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="无括号"><a href="#无括号" class="headerlink" title="无括号"></a>无括号</h2><p>$$<br>\begin{matrix}<br>1 &amp; 2 &amp; 3 \<br>4 &amp; 5 &amp; 6 \<br>7 &amp; 8 &amp; 9<br>\end{matrix}<br>$$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">1 &amp; 2 &amp; 3 \\</span><br><span class="line">4 &amp; 5 &amp; 6 \\</span><br><span class="line">7 &amp; 8 &amp; 9</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h2 id="圆括号"><a href="#圆括号" class="headerlink" title="圆括号"></a>圆括号</h2><blockquote><p><strong>pmatrix</strong> (parentheses brackets matrix)</p></blockquote><p>$$<br>\begin{pmatrix}<br>1 &amp; 2 &amp; 3 \<br>4 &amp; 5 &amp; 6 \<br>7 &amp; 8 &amp; 9<br>\end{pmatrix}<br>$$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;pmatrix&#125;</span><br><span class="line">1 &amp; 2 &amp; 3 \\</span><br><span class="line">4 &amp; 5 &amp; 6 \\</span><br><span class="line">7 &amp; 8 &amp; 9</span><br><span class="line">\end&#123;pmatrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h2 id="方括号"><a href="#方括号" class="headerlink" title="方括号"></a>方括号</h2><blockquote><p><strong>bmatrix</strong> (brackets matrix)</p></blockquote><p>$$<br>\begin{bmatrix}<br>1 &amp; 2 &amp; 3 \<br>4 &amp; 5 &amp; 6 \<br>7 &amp; 8 &amp; 9<br>\end{bmatrix}<br>$$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;bmatrix&#125;</span><br><span class="line">1 &amp; 2 &amp; 3 \\</span><br><span class="line">4 &amp; 5 &amp; 6 \\</span><br><span class="line">7 &amp; 8 &amp; 9</span><br><span class="line">\end&#123;bmatrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h2 id="花括号"><a href="#花括号" class="headerlink" title="花括号"></a>花括号</h2><p>$$<br>\begin{Bmatrix}<br>1 &amp; 2 &amp; 3 \<br>4 &amp; 5 &amp; 6 \<br>7 &amp; 8 &amp; 9<br>\end{Bmatrix}<br>$$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;Bmatrix&#125;</span><br><span class="line">1 &amp; 2 &amp; 3 \\</span><br><span class="line">4 &amp; 5 &amp; 6 \\</span><br><span class="line">7 &amp; 8 &amp; 9</span><br><span class="line">\end&#123;Bmatrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h2 id="单竖线括号"><a href="#单竖线括号" class="headerlink" title="单竖线括号"></a>单竖线括号</h2><blockquote><p><strong>vmatrix</strong> (vertical bar brackets matrix)</p></blockquote><p>$$<br>\begin{vmatrix}<br>1 &amp; 2 &amp; 3 \<br>4 &amp; 5 &amp; 6 \<br>7 &amp; 8 &amp; 9<br>\end{vmatrix}<br>$$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;vmatrix&#125;</span><br><span class="line">1 &amp; 2 &amp; 3 \\</span><br><span class="line">4 &amp; 5 &amp; 6 \\</span><br><span class="line">7 &amp; 8 &amp; 9</span><br><span class="line">\end&#123;vmatrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h2 id="双竖线括号"><a href="#双竖线括号" class="headerlink" title="双竖线括号"></a>双竖线括号</h2><p>$$<br>\begin{Vmatrix}<br>1 &amp; 2 &amp; 3 \<br>4 &amp; 5 &amp; 6 \<br>7 &amp; 8 &amp; 9<br>\end{Vmatrix}<br>$$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;Vmatrix&#125;</span><br><span class="line">1 &amp; 2 &amp; 3 \\</span><br><span class="line">4 &amp; 5 &amp; 6 \\</span><br><span class="line">7 &amp; 8 &amp; 9</span><br><span class="line">\end&#123;Vmatrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><blockquote><p>参考</p><ul><li>[1] <a href="https://blog.csdn.net/u012684062/article/details/78398191">各种数学符号</a></li><li>[2] <a href="https://www.math-linux.com/latex-26/faq/latex-faq/">转义表示</a></li></ul></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/02/07/ji-qi-xue-xi/shen-du-xue-xi/"/>
      <url>/2023/02/07/ji-qi-xue-xi/shen-du-xue-xi/</url>
      
        <content type="html"><![CDATA[<iframe src="https://g-ghy.github.io/mindmap/machine_learning.html" width="100%" height="400" frameborder="0" scrolling="yes" leftmargin="0" topmargin="0"></iframe><blockquote><p>参考</p><ul><li>[1] <a href="https://www.ctocio.com/hotnews/15919.html">机器学习算法简介</a></li><li>[2] <a href="https://www.cnblogs.com/maybe2030/p/4665816.html">机器学习算法汇总</a></li></ul></blockquote><h1 id="深度学习介绍"><a href="#深度学习介绍" class="headerlink" title="深度学习介绍"></a>深度学习介绍</h1><p><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301111547493.png"></p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>1.安装<a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA</a><br>2.安装anaconda或miniconda<br>3.安装GPU版<a href="https://pytorch.org/get-started/locally/">Pytorch</a><br><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301092357818.png"><br>4.安装d2l和Jupyter<br><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301092357302.png"></p><blockquote><p>注: 第3步中如果安装anaconda，则Jupyter会附加安装</p></blockquote><blockquote><p>问题</p><ol><li>控制台输入 <code>python</code> 跳转至 Microsoft Store<br>解决方法：Windows设置 –&gt; 应用 –&gt; 应用和功能 –&gt; 应用执行别名 –&gt; 关闭应用安装程序(python.exe, python3.exe)</li></ol></blockquote><h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote><p>标量-&gt;向量-&gt;矩阵-&gt;张量</p></blockquote><h3 id="标量"><a href="#标量" class="headerlink" title="标量"></a>标量</h3><ul><li>标量由只有一个元素的张量表示，例如<code>tensor(5)</code></li></ul><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><ul><li>向量可以被视为标量值组成的列表，例如<code>tensor([0, 1, 2, 3])</code></li><li>向量通常记为粗体、小写的符号(例如<strong>x</strong>, <strong>y</strong>, <strong>z</strong>)</li><li>向量的长度&#x2F;向量中元素数量通常称为向量的维度</li></ul><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><ul><li>矩阵是向量从一阶推广到二阶的结果，在代码中表示为具有两个轴的张量，例如<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor([[ 0,  1,  2,  3],</span><br><span class="line">        [ 4,  5,  6,  7],</span><br><span class="line">        [ 8,  9, 10, 11],</span><br><span class="line">        [12, 13, 14, 15],</span><br><span class="line">        [16, 17, 18, 19]])</span><br></pre></td></tr></table></figure></li><li>通常用粗体、大写字母来表示（例如<strong>X</strong>，<strong>Y</strong>，<strong>Z</strong>）</li></ul><h3 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h3><ul><li>描述具有任意数量<strong>轴</strong>的𝑛维数组的通用方法，并未要求一定要$\geq$3阶。例如，向量是一阶张量，矩阵是二阶张量。</li><li>张量的维度表示张量具有的轴数。 在这个意义上，张量的某个轴的维数就是这个轴的长度</li></ul><blockquote><p>注意<strong>维度</strong>一概念对于向量和张量的不同解释</p></blockquote><h2 id="“乘法”"><a href="#“乘法”" class="headerlink" title="“乘法”"></a>“乘法”</h2><ol><li>Hadamard积，对应元素相乘，<code>A * B</code></li><li>向量点积，相同位置的按元素乘积的和，<code>torch.dot(x, y)</code></li><li>矩阵-向量乘法，<code>torch.mv(A, x)</code></li><li>矩阵-矩阵乘法，<code>torch.mm(A, B)</code></li></ol><blockquote><p>注意区分 Hadamard积 和 矩阵乘法</p></blockquote><h2 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h2><blockquote><p>如何理解指定张量沿哪一个轴来通过<code>tensor.sum()</code>方法求和降低维度这一功能的实际表现</p></blockquote><p>在第一次看到这个方法时，令人费解的是<code>axis</code>这一参数该如何理解。<br>为了方便论述，取一个三维的张量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">X = torch.arange(8).reshape(2, 2, 2)</span><br><span class="line">&gt; [</span><br><span class="line">    [</span><br><span class="line">      [0, 1],</span><br><span class="line">      [2, 3]</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      [4, 5],</span><br><span class="line">      [6, 7]</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301120025311.png"></p><h3 id="单轴降维"><a href="#单轴降维" class="headerlink" title="单轴降维"></a>单轴降维</h3><p>如果把一对括号括起来的部分看为一个集合，集合内元素个数就是所谓的各个维度对应的数值，上图中橙色的2表示最外层的括号内部有2个元素，绿色和蓝色的含义与此相同，所以说当axis指定0时，意思就是看外层的黄色括号，把内部的两个元素进行求和，此时如果<code>keepdims = False</code>也就意味着要将最外层的这一维度去掉，即下图所示<br><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301120042764.png"><br>如果<code>keepdims = True</code>，那么将保留最外层的这一维度，即下图所示<br><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301120035823.png"></p><p>当axis指定1时，意思就是看中间的绿色括号，把内部的2个元素进行求和，当<code>keepdims = False</code>时，即下图所示，<br><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301120044454.png"></p><p>如果<code>keepdims = True</code>，那么将保留中间层的这一维度，即下图所示<br><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301120045906.png"></p><h3 id="多轴降维"><a href="#多轴降维" class="headerlink" title="多轴降维"></a>多轴降维</h3><blockquote><p>核心问题是：当指定axis&#x3D;(0,1)时，1是原张量的第1维度还是先对原张量的第0维度进行降维后的新张量的第1维度</p></blockquote><p>验证方法很简单，只需要对比原张量按照axis&#x3D;(0, 1)进行降维的结果和先对原张量的第0维进行降维，再分别对新张量的第0维和第1维降维的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 原张量 X = torch.arange(8).reshape(2, 2, 2)</span><br><span class="line">[</span><br><span class="line">    [</span><br><span class="line">      [0, 1],</span><br><span class="line">      [2, 3]</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      [4, 5],</span><br><span class="line">      [6, 7]</span><br><span class="line">    ]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 对第0维和第1维进行求和降维 X.sum(axis = (0, 1), keepdims = False)</span><br><span class="line">[12, 16]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 对第0维进行求和降维 </span><br><span class="line">[</span><br><span class="line"> [ 4,  6],</span><br><span class="line"> [ 8, 10]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 对上方结果对第0维(原张量的第1维)进行求和降维</span><br><span class="line">[12, 16]</span><br><span class="line"></span><br><span class="line">// 对上方结果对第1维(原张量的第2维)进行求和降维</span><br><span class="line">[10, 18]</span><br></pre></td></tr></table></figure><blockquote><p>结论：从上方结果可以看出，当指定axis &#x3D; (0, 1)时，0和1是针对原张量而言的，如果一定要分开来说，就是先对原张量第0维进行降维，再对降维结果的第0维(原张量的第1维)进行降维</p></blockquote><h2 id="矩阵计算-向量求导"><a href="#矩阵计算-向量求导" class="headerlink" title="矩阵计算-向量求导"></a>矩阵计算-向量求导</h2><p>国内外关于<code>凹凸函数</code>的定义略有不同，同济大学高等数学教材对函数的凹凸性定义为函数的下方图是凹集或凸集，国外的凹凸性是指函数的上方图是凹集或凸集</p><p><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301220759216.png"></p><h3 id="标量对向量求导"><a href="#标量对向量求导" class="headerlink" title="标量对向量求导"></a>标量对向量求导</h3><p><strong>求导方法</strong><br>对于多元函数<br>$$<br>f(x_1, x_2, x_3) &#x3D; x_1^2 + x_1 x_2 + x_2 x_3 \<br>$$</p><p>$f$对$x_1$, $x_2$, $x_3$的偏导分别为<br>$$<br>\left{<br>\begin{align*}<br>\frac{\partial f}{\partial x_1} &amp; &#x3D; 2x_1+x_2 \\<br>\frac{\partial f}{\partial x_2} &amp; &#x3D; x_1+x_3 \\ \frac{\partial f}{\partial x_3} &amp; &#x3D; x_2<br>\end{align*}<br>\right. \<br>$$</p><h1 id="标量对向量求导的本质就是标量中的每个部分分别对向量中的每个元素逐个求偏导，并将结果写成向量、矩阵的形式-frac-partial-f-pmb-x-partial-pmb-x-3-times1"><a href="#标量对向量求导的本质就是标量中的每个部分分别对向量中的每个元素逐个求偏导，并将结果写成向量、矩阵的形式-frac-partial-f-pmb-x-partial-pmb-x-3-times1" class="headerlink" title="标量对向量求导的本质就是标量中的每个部分分别对向量中的每个元素逐个求偏导，并将结果写成向量、矩阵的形式$$\frac{\partial f(\pmb{x})}{\partial \pmb{x}_{3\times1}}"></a>标量对向量求导的本质就是标量中的每个部分分别对向量中的每个元素逐个求偏导，并将结果写成向量、矩阵的形式<br>$$<br>\frac{\partial f(\pmb{x})}{\partial \pmb{x}_{3\times1}}</h1><h1 id="begin-bmatrix-frac-partial-f-partial-x-1-frac-partial-f-partial-x-2-frac-partial-f-partial-x-3-end-bmatrix"><a href="#begin-bmatrix-frac-partial-f-partial-x-1-frac-partial-f-partial-x-2-frac-partial-f-partial-x-3-end-bmatrix" class="headerlink" title="\begin{bmatrix}\frac{\partial f}{\partial x_1}\\frac{\partial f}{\partial x_2}\\frac{\partial f}{\partial x_3}\\end{bmatrix} "></a>\begin{bmatrix}<br>\frac{\partial f}{\partial x_1}\<br>\frac{\partial f}{\partial x_2}\<br>\frac{\partial f}{\partial x_3}\<br>\end{bmatrix} </h1><p>\begin{bmatrix}<br>2x_1+x_2 \<br>x_1+x_3 \<br>x_2<br>\end{bmatrix}<br>$$</p><p><strong>示例</strong></p><blockquote><p>$$<br>y &#x3D; {x_1}^2 + 2{x_2}^2 \<br>X &#x3D; \begin{bmatrix}<br>x_1 \<br>x_2<br>\end{bmatrix} \<br>\frac{\partial y}{\partial X} &#x3D; \begin{bmatrix} 2x_1, 4x_2 \end{bmatrix}<br>$$</p></blockquote><p>根据沐神的讲解，标量y表示为一个等高线，而标量y对向量X求导后的结果在代入某一点时表示一个<a href="https://www.cnblogs.com/shine-lee/p/11715033.html">梯度</a>，是和等高线在该点是正交的，<strong>梯度指向值变化最大的方向</strong><br>其他示例如下图所示<br><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301221946005.png"><br>$$<br>sum(x) &#x3D; x_1 + x_2 + x_3 + \cdots + x_n \<br>\frac{\partial }{\partial X}sum(x) &#x3D;<br>\begin{bmatrix}<br>1 &amp; 1 &amp; \cdots &amp; 1<br>\end{bmatrix}<br>&#x3D; 1^T<br>$$</p><p>$$<br>{\begin{Vmatrix} X \end{Vmatrix}}^2 &#x3D; {x_1}^2 + {x_2}^2 + \cdots + {x_n}^2 \<br>\frac{\partial }{\partial X}{\begin{Vmatrix} X \end{Vmatrix}}^2 &#x3D; \begin{bmatrix} 2x_1 &amp; 2x_2 &amp; \cdots &amp; 2x_n \end{bmatrix} &#x3D; 2X^T<br>$$</p><h3 id="向量对标量求导"><a href="#向量对标量求导" class="headerlink" title="向量对标量求导"></a>向量对标量求导</h3><p>$$<br>Y &#x3D; \begin{bmatrix} y_1 \ y_2 \ y_3 \end{bmatrix} \\<br>\frac{\partial Y}{\partial x} &#x3D;<br>\begin{bmatrix}<br>\frac{\partial y_1}{\partial x} \<br>\frac{\partial y_2}{\partial x} \<br>\frac{\partial y_3}{\partial x} \<br>\end{bmatrix}<br>$$</p><h3 id="向量对向量求导"><a href="#向量对向量求导" class="headerlink" title="向量对向量求导"></a>向量对向量求导</h3><p>根据下图求导时的展开规则，求导后矩阵行数同$Y$的行数，列数同$X$的行数<br><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301230943566.png"></p><h1 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h1><ul><li>将代码分解为操作子</li><li>将求导计算表示为一个无环图</li></ul><p>自动求导是基于链式法则，但有2种计算模式：1.正向累积 2.反向累积(反向传递)<br>正向是求复合函数的值，反向是计算偏导数和梯度</p><h1 id="线性回归模型"><a href="#线性回归模型" class="headerlink" title="线性回归模型"></a>线性回归模型</h1><blockquote><p>为了便于描述，规定场景为房价预测，即根据房屋面积和房龄预测房屋价格</p></blockquote><blockquote><p>四要素<br>Model           $f_{w,b}(x) &#x3D; wx + b$<br>Parameters      $w, b$<br>Cost Function   $J(w,b) &#x3D; \frac{1}{2m} \sum \limits_{i&#x3D;1} \limits^m (f_{w,b}(x^{(i)}) - y^{(i)})^2$<br>Objective       $\mathop{minimize} \limits_{w,b} J(w, b)$</p></blockquote><p><img src="https://img2023.cnblogs.com/blog/1898659/202302/1898659-20230202084246405-1828005329.png"><br>左上是model的图像,剩余两个都是代价函数,对于下方图像,很多垂直于j轴方向的平面与代价函数图像相交后会形成很多线,这些线汇聚在一起就是右上的图像</p><p>目标就是最小化代价函数</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>在房价预测问题中，model为$price &#x3D; w_{area} \cdot area + w_{age} \cdot age + b$</p><p>采用线代代数的表示方式，对于一个样本而言，将权重$w_i$置于向量$\mathbf{w}$中，即$[w_{area}, w_{age}]^\top$。将特征置于向量$\mathbf{x}$中，即$[area, age]^\top$。因此根据向量乘法可得model为$price &#x3D; \mathbf{w}^\top \mathbf{x} + b$</p><p>多个样本与单一样本的区别在于特征值由一组变为多组，即多个$\mathbf{x}$,将他们以行向量的形式置于一个大的矩阵，可得$\mathbf{X}$，它的每一行是一个样本$\mathbf{x}^\top$，此时model为$\mathbf{X} \mathbf{w} + b$</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>直观理解就是模型值和实际值的差距</p><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>起初一个令人疑惑的问题是梯度下降使用的等高线是哪里来的,<br>在线性回归模型中,model的图像是一个三维空间,当指定x和y值时,对应一个高度,该高度值为model的值,这一图像就像是一座山,如下图所示<br><img src="https://img2023.cnblogs.com/blog/1898659/202302/1898659-20230202082142889-1975618713.png"></p><p>换个视角来看,就变为了等高线图,在三维图中寻找局部最优解的过程对应着等高线图中梯度下降的过程<br><img src="https://img2023.cnblogs.com/blog/1898659/202302/1898659-20230202082222654-184290546.png"></p><p>上面说的有问题,我们希望最小化代价函数,因此我们应该是考虑函数j,因此三维图是j,w,b的函数,等高线上相同线上的代价函数j值是相同的,我们寻求的是j的局部最优解</p><p>当仅存在一个变量时,梯度下降是按照下面这样理解的<br><img src="https://img2023.cnblogs.com/blog/1898659/202302/1898659-20230206090949844-1393311918.png"><br>线性回归问题只不过是由上述的单变量w变为了双变量w和b,梯度下降就变为对两个变量分别进行梯度下降,于是线性回归问题的梯度下降就是按照下面这样进行的<br><img src="https://img2023.cnblogs.com/blog/1898659/202302/1898659-20230206091143570-1024228897.png"></p><p>只有凸函数(外国的定义)具有全局最小值,否则w和b的选择不同可能会到达不同的局部最小值,但不一定一定可以到达全局最小值</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>[1] <a href="https://www.cnblogs.com/shine-lee/p/11715033.html">直观理解梯度，以及偏导数、方向导数和法向量</a></li><li>[2] <a href="https://www.cnblogs.com/bingjianing/p/9014246.html">导数、方向导数与梯度</a></li><li>[3] <a href="https://netedu.xauat.edu.cn/jpkc/netedu/jpkc/gdsx/homepage/5jxsd/51/513/5308/530807.htm">第七节  方向导数与梯度</a></li><li>[4] <a href="https://dezeming.top/wp-content/uploads/2021/07/%E5%87%BD%E6%95%B0%E5%AF%B9%E5%90%91%E9%87%8F%E6%B1%82%E5%AF%BC-%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E6%8F%8F%E8%BF%B0.pdf">函数对向量求导通俗理解</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/02/07/golang/json-web-tokens/"/>
      <url>/2023/02/07/golang/json-web-tokens/</url>
      
        <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.kennycoder.io/2020/01/05/Golang-JSON-Web-Tokens-JWT-%E7%A4%BA%E7%AF%84/">Golang - JSON Web Tokens （JWT） 示范</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/02/07/golang/goroot-gopath-go-modules-san-zhe-de-guan-xi-jie-shao/"/>
      <url>/2023/02/07/golang/goroot-gopath-go-modules-san-zhe-de-guan-xi-jie-shao/</url>
      
        <content type="html"><![CDATA[<h1 id="GOROOT"><a href="#GOROOT" class="headerlink" title="GOROOT"></a>GOROOT</h1><blockquote><p>GOROOT路径即为存放Golang语言内建的程序库的所在位置,简单地说就是Golang的安装路径</p></blockquote><p>若按照<a href="https://go.dev/doc/install">Folang-Download and install流程</a>,则由<code>go env</code>命令查询到的结果为<code>GOROOT=&quot;/usr/local/go&quot;</code></p><h1 id="GOPATH-和-Go-Modules"><a href="#GOPATH-和-Go-Modules" class="headerlink" title="GOPATH 和 Go Modules"></a>GOPATH 和 Go Modules</h1><blockquote><p>GOPATH 是一个路径,若初次安装Golang且未修改环境变量,则GOPATH默认为<strong>用户目录</strong>下的go文件夹(例如root用户的默认GOPATH为<code>/root/go</code>,普通用户user的默认GOPATH为<code>/home/user/go</code>)</p></blockquote><blockquote><p>Go Modules 是Go 1.11版本之后发布的dependency management system </p></blockquote><p>从上述概念来说,二者是没有任何联系的,但是GOPATH的概念并不能体现出其在项目构建上的作用<br>这两个概念看似不相干,但实际上他们代表着先后两种项目构建模式:经典的GOPATH mode 和 目前的go Modules mode,这两个概念是两种设计模式的产物,并不能说二者毫无关联,因为在Go Modules模式下仍然会使用到GOPATH(go install会将可执行文件放置于$GOPATH&#x2F;bin下)<br>之所以混乱,是因为其是一个历史发展的过程,而且后者模式并没有完全脱离前者,</p><h2 id="经典的GOPATH-mode"><a href="#经典的GOPATH-mode" class="headerlink" title="经典的GOPATH mode"></a>经典的GOPATH mode</h2><p>此模式下,项目结构如下图所示<br><img src="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202302041747802.png"></p><h2 id="目前的go-Modules-mode"><a href="#目前的go-Modules-mode" class="headerlink" title="目前的go Modules mode"></a>目前的go Modules mode</h2><h1 id="Go-Modules"><a href="#Go-Modules" class="headerlink" title="Go Modules"></a>Go Modules</h1><p>想要理解Go Modules,需要理清Go project构建方式的发展历程.</p><ol><li>在Go 1.11版本之前,代码分为两种情况,一是<code>import</code>语言内建的程序库(位于<code>$GOROOT/pkg</code>下),另一种是<code>import</code>第三方的程序库</li></ol><p>对于前者,在任意目录下仅需要创建以下单文件,执行<code>go run main.go</code>命令即可运行,<code>go run</code>将代码进行编译并生成执行文件，而编译文件跟执行文件存在一个暂存文件夹内，当运行完此程序就会自动删除。 该指令可以想成类似解释的方式运行，而不需要做其他任何环境设定，即可运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// main.go</span><br><span class="line">package main</span><br><span class="line"> ​</span><br><span class="line"> import &quot;fmt&quot;</span><br><span class="line"> ​</span><br><span class="line"> func main() &#123;</span><br><span class="line">     fmt.Println(&quot;Hello World&quot;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>对于后者,同样的单文件执行<code>go run main.go</code>命令,会出现以下错误.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// main.go</span><br><span class="line">package main</span><br><span class="line"> ​</span><br><span class="line"> import &quot;github.com/gin-gonic/gin&quot;</span><br><span class="line"> ​</span><br><span class="line"> func main() &#123;</span><br><span class="line">     router := gin.Default()</span><br><span class="line">     router.Run()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>由错误信息可知,第三方包的搜索顺序是<code>$GOROOT/src/</code>-&gt;<code>$GOPATH/src/</code>,若两个路径下都未找到,则代码无法运行.</p><blockquote><p>main.go:2:8: cannot find package “github.com&#x2F;gin-gonic&#x2F;gin” in any of:</p><p>&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;github.com&#x2F;gin-gonic&#x2F;gin (from $GOROOT)</p><p>&#x2F;root&#x2F;go&#x2F;src&#x2F;github.com&#x2F;gin-gonic&#x2F;gin (from $GOPATH)</p></blockquote><p>不难注意到,两个路径中都涉及到一个<code>src</code>目录,实际上在Go 1.11版本之前的项目结构如下图所示,</p><ul><li>bin: 存放<code>go build</code>编译生成的可执行文件,<code>go build &lt;filename&gt;</code>会在指定文件的当前目录生成可执行文件;<code>go build &lt;projectname&gt;</code>会在当前目录生成<code>$GOPATH/src/projectname</code>编译出的可执行文件;可通过<code>-o</code>参数指定输出文件的路径,但源文件的根路径只能是<code>$GOPATH/src</code>,无法指定其他路径</li><li>pkg: 当项目过大时,<code>go build</code>的编译速度很慢,</li><li>src: 存放项目的源代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[Go-project] --- B[bin]</span><br><span class="line">A[Go-project] --- C[pkg]</span><br><span class="line">A[Go-project] --- D[src]</span><br></pre></td></tr></table></figure><p>在理解这3个目录的作用之前,首先需要理解一下<br>关于这3个目录的作用,需要首先理解2个命令,<code>go build</code> 和 <code>go install</code><br><code>go build &lt;filename&gt;</code>: 在<filename>的当前目录生成可执行文件<br><code>go build &lt;projectname&gt;</code>: 在当前目录生成<code>$GOPATH/src/projectname</code>编译出的可执行文件<br><code>go install &lt;main包-filename&gt;</code>:<br><code>go install &lt;main包-filename&gt;</code>: </p><ol start="2"><li>在Go 1.11版本之前</li></ol><p>至此虽然搞清了GOROOT和GOPATH的具体值,但是它们究竟起到何种作用仍然是不清晰的.起到干扰作用的<br>在后续的coding过程中,会很自然地发现一个问题<br>在,构建一个go project的方式为</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://medium.com/%E4%BC%81%E9%B5%9D%E4%B9%9F%E6%87%82%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/golang-goroot-gopath-go-modules-%E4%B8%89%E8%80%85%E7%9A%84%E9%97%9C%E4%BF%82%E4%BB%8B%E7%B4%B9-d17481d7a655">Golang — GOROOT、GOPATH、Go-Modules-三者的关系介绍</a></li></ul><p>在传统gopath模式下,多项目的构建方式令人疑惑</p><ul><li><a href="http://www.17bigdata.com/study/programming/it-go/it-go-211333.html">go设置多个GOPATH的方式</a></li><li><a href="https://www.zhihu.com/question/425936077/answer/1529637747">Golang应该如何组织多个项目的目录结构？</a></li></ul><p>在考虑传统模式下多项目的构建方式时,尝试在$GOPATH&#x2F;src&#x2F;project下创建2个文件,一个文件package写的非main,另一个文件package写的main,完全不对<br>然后不知道怎么就想到go文件里面写的package又可以和所在目录名称不同,这样对于包的理解就出现了疑惑,感觉有点混乱</p><ul><li><p><a href="http://c.biancheng.net/view/5394.html">Go语言包的基本概念</a></p></li><li><p><a href="https://qiankunli.github.io/2020/03/15/go_package.html#%E5%8C%85%E7%AE%A1%E7%90%86">go打包机制</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/02/07/python/conda/"/>
      <url>/2023/02/07/python/conda/</url>
      
        <content type="html"><![CDATA[<p>Conda是一个开源[2]跨平台[3]语言无关[4]的包管理与环境管理系统<br>pip是一个以Python计算机程序语言写成的软件包管理系<br>在安装包方面，二者都可以做到，但有不同。可以使用conda管理虚拟环境，进入某一环境后使用pip安装，具体区别暂未了解<br>conda可以创建不同环境，不同环境间相互隔离，可以避免包冲突，可以解决开发过程中需要使用多环境的问题</p><p>查看当前虚拟环境列表：<code>conda env list</code></p><p>新建虚拟环境：<code>conda create --name &lt;virtual environment name&gt;</code></p><p>进入虚拟环境:<code>conda activate &lt;virtual environment name&gt;</code></p><p>推出虚拟环境：<code>conda deactivate</code></p><p>删除虚拟环境: <code>conda remove --name &lt;virtual environment name&gt; --all</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/28/hello-world/"/>
      <url>/2023/01/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
